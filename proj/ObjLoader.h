#ifndef OBJ_H
#define OBJ_H

#include <vector>
#include <string>
#include "vector3d.h"

//#define USE_STXXL

#ifdef USE_STXXL
#include "stxxl.h"
/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
#endif

struct Vector3df
{
	float g[3];
	Vector3df()
	{
		g[0] = g[1] = g[2] = 0.0f;
	}
};
struct color_Vector3df
{
	float g[4];
	color_Vector3df()
	{
		g[0] = g[1] = g[2] = g[3] = 0.0f;
	}
};
struct UV3df
{
	float g[2];
	UV3df()
	{
		g[0] = g[1] = 0.0f;
	}
};

inline float vectorlength_g( const float* g)
{
	return g[0]*g[0] + g[1]*g[1] + g[2]*g[2];
}
struct idx
{
	unsigned int g[3];
	idx()
	{
		g[0] = g[1] = g[2] = 0;
	}
};

//typedef float Vector3df[3];
//typedef float color_Vector3df[4];
//typedef float UV3df[2];
//typedef unsigned int idx[3];

#ifdef USE_STXXL
typedef stxxl::VECTOR_GENERATOR<Vector3df>::result			vector_Vector3df;
typedef stxxl::VECTOR_GENERATOR<color_Vector3df>::result	vector_color_Vector3df;
typedef stxxl::VECTOR_GENERATOR<UV3df>::result				vector_UV3df;
typedef stxxl::VECTOR_GENERATOR<idx>::result				vector_idx;
#else
typedef std::vector< Vector3df >		vector_Vector3df;
typedef std::vector<color_Vector3df>	vector_color_Vector3df;
typedef std::vector<UV3df>				vector_UV3df;
typedef std::vector<idx>				vector_idx;
#endif

class ObjMaterial
{
public:
	std::string name;
	std::string texture_name;
	std::string alp_texture_name;
	std::string bump_texture_name;
	color_Vector3df ambient;
	color_Vector3df diffuse;
	color_Vector3df specular;
	color_Vector3df emission;
	float shininess;
	float roughness;
	float refraction_index;

	int user_ReflectionType;	//自前の反射属性(material.hのenum ReflectionTypeの値)
	float ward[2];

	int texture_repeat;

	char smooth;
	ObjMaterial()
	{
		Init();
	}
	void Init()
	{
		texture_repeat = 1;
		smooth = '\0';
		name = "";
		texture_name = "";
		alp_texture_name = "";
		bump_texture_name = "";
		ambient.g[0] = ambient.g[1] = ambient.g[2] = 0.0f;
		diffuse.g[0] = diffuse.g[1] = diffuse.g[2] = 0.0f;
		specular.g[0] = specular.g[1] = specular.g[2] = 0.0f;
		emission.g[0] = emission.g[1] = emission.g[2] = 0.0f;
		
		//未定義値
		ambient.g[3] = -1.0f;
		diffuse.g[3] = -1.0f;
		specular.g[3] = -1.0f;
		emission.g[3] = -1.0f;

		shininess = 5.0f;
		textureImage = 0;
		bump_textureImage = 0;
		alp_textureImage = 0;
		user_ReflectionType = -1;
		ward[0] = ward[1] = 0.0;
		roughness = 0.0;
		refraction_index = 0;
	}
	void* textureImage;
	void* alp_textureImage;
	void* bump_textureImage;
};


class Obj 
{
public:
  float max[3], min[3];
  float mid[3];
  float daiag;
  float size[3];
  double smooth;
 
  bool set_color;

  int nv, nf, nvn, ntn;
  vector_Vector3df vert;
  vector_Vector3df norm;
  vector_Vector3df fnorm;
  vector_color_Vector3df color;
  vector_UV3df uv;
  vector_idx face;
  vector_idx norm_id;
  vector_idx texture_id;

  std::string materialName;
  std::vector<int> texture_material_id;
  std::vector<ObjMaterial> texture_material;

  Obj()
  {};

  Obj(char *file, int* rgb=0);
  virtual ~Obj();

  bool LoadMTLFile();

  void CalcNormalVector();
  void CalcNormalVectorChk();
  void dump();
  void dump2();

  void realloc_face(int f);
	//char * GetDirectoryName(const char *filename, char *dest)
	//{
	//	char *strings = NULL;
	//	char *dir;
	//	dir = new char [strlen(filename)+1];
	//	strcpy(dir, filename);
	//	if ( strings = strrchr(dir, '/' ) ) strings[1] = '\0';
	//	else if ( strings = strrchr(dir, '\\') ) strings[1] ='\0';
	//	else dir[0] = '\0';
	//	strcpy(dest, dir);
	//	return dest;
	//}

	//char * SetDirectoryName( char *dest, char *directory )
	//{
	//	char *s = "";
	//	s = new char [strlen(directory) + strlen(dest) + 1];
	//	strcpy( s, directory );
	//	strcat( s, dest );
	//	return s;
	//}
	inline prender::Vector3d vertex(const int id) const
	{
		return prender::Vector3d(vert[id].g[0], vert[id].g[1], vert[id].g[2]);
	}
	inline prender::Vector3d texcoord(const int id) const
	{
		return prender::Vector3d(uv[id].g[0], uv[id].g[1], 0.0);
	}
	inline prender::Vector3d fnormal(const int id) const
	{
		return prender::Vector3d(fnorm[id].g[0], fnorm[id].g[1], fnorm[id].g[2]);
	}
	inline prender::Vector3d normal(const int id) const
	{
		return prender::Vector3d(norm[id].g[0], norm[id].g[1], norm[id].g[2]);
	}
	inline prender::Vector3d vertex_color(const int id) const
	{
		return prender::Vector3d(color[id].g[0], color[id].g[1], color[id].g[2]);
	}
};



#endif
